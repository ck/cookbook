h2. Cookbook Application

This application we're creating in this document serves two purposes. 
First is demonstrates the use of MerbAuth slices in a Merb-based application. Second, it acts as a test harness for updates to the used gems and slices.

h2. Overview

This document describes the steps to create a simple cookbook application using the following, best-of-bread tools:

* Merb
* DataMapper
* HAML
* RSpec
* MerbAuth

Disclaimer: The main purpose is to show the use of MerbAuth and its slices and not the modeling of an application!

h2. Preparation

First, let us install all necessary gems.
                                         
TODO describe the steps.

h2. Steps

h3. Skeleton App

Create the skeleton

@$ merb-gen app cookbook --orm datamapper  --template-engine haml  --testing-framework rspec@

@$ cd cookbook@


Next we adjust the dependencies in the @config/init.rb@ file. Comment out listed dependencies and add other ones:

<pre><code>
	# dm-more dependencies
	dependency 'dm-timestamps'
	dependency 'dm-types'
	dependency 'dm-serializer'
	dependency 'dm-validations'
	
	# merb-more dependencies
	dependency 'merb-action-args'
	dependency 'merb-assets'
	dependency 'merb-builder'
	dependency 'merb-cache'
	dependency 'merb-haml'
	dependency 'merb-helpers'
	dependency 'merb-jquery'
	dependency 'merb-mailer'
	dependency 'merb-slices'
	
	# merb-plugins dependencies
	dependency 'merb_param_protection'
</code></pre>

In order to define the connection to the database we have two options

# established the database connection in the environment files
# define the database connection parameters in a separate configuration file

We will use the old fashion method and use the @config/database.yml@ file. Create the file and define the connection parameters (adjust to your environment as needed):

<pre><code>
	---
	:development: &defaults
	  :adapter: mysql
	  :database: cookbook_development
	  :username: cb_user
	  :password: secret
	  :host: localhost
	
	:test:
	  <<: *defaults
	  :database: cookbook_test
	
	:production:
	  <<: *defaults
	  :database: cookbook_production
	
	:rake:
	  <<: *defaults
</code></pre>


Refer to your database manual on create the database.

Since we use thread-safe DataMapper as our ORM we can also turn the mutex off in the @Merb.config@:

<pre><code>
	Merb::Config.use do |c|
	
		...
	
		c[:use_mutex] = false
	end
</code></pre>

That's it for setup. We have an application that has no models, no controllers, and no views. In sort: that does nothing!


h3. Add Authentication

h4. Add dependencies

Next we add the user model and the proper authentication.

First, let's add the MerbAuth password slice to @config/init.rb@ :

<pre><code>
	# merb_auth dependencies
	dependency "merb_auth-core"
	dependency "merb_auth-more"
	dependency "merb_auth_password_slice"
</code></pre>

Now if we run @rake -T slices:merb_auth_password_slice@ we get all kinds of goodies:

<pre><code>
	rake slices:merb_auth_password_slice:copy_assets          # Copy public assets to host application
	rake slices:merb_auth_password_slice:freeze               # Freeze MerbAuthPasswordSlice into your app (only merb_auth_password_slice/app)
	rake slices:merb_auth_password_slice:freeze:app           # Freezes MerbAuthPasswordSlice by copying all files from merb_auth_password_slice/ap...
	rake slices:merb_auth_password_slice:freeze:app_with_gem  # Freezes MerbAuthPasswordSlice as a gem and copies over merb_auth_password_slice/app
	rake slices:merb_auth_password_slice:freeze:gem           # Freezes MerbAuthPasswordSlice by installing the gem into application/gems using mer...
	rake slices:merb_auth_password_slice:freeze:models        # Freeze all models into your application for easy modification
	rake slices:merb_auth_password_slice:freeze:unpack        # Freezes MerbAuthPasswordSlice by unpacking all files into your application
	rake slices:merb_auth_password_slice:freeze:views         # Freeze all views into your application for easy modification
	rake slices:merb_auth_password_slice:install              # Install MerbAuthPasswordSlice
	rake slices:merb_auth_password_slice:migrate              # Migrate the database / Migrate the database
	rake slices:merb_auth_password_slice:patch                # Copy stub files and views to host application
	rake slices:merb_auth_password_slice:preflight            # Test for any dependencies / Test for any dependencies
	rake slices:merb_auth_password_slice:setup_directories    # Setup directories
	rake slices:merb_auth_password_slice:spec                 # Run slice specs within the host application context
	rake slices:merb_auth_password_slice:spec:controller      # Run all controller specs, run a spec for a specific Controller with CONTROLLER=MyCo...
	rake slices:merb_auth_password_slice:spec:default         # Run specs
	rake slices:merb_auth_password_slice:spec:html            # Run all specs and output the result in html
	rake slices:merb_auth_password_slice:spec:model           # Run all model specs, run a spec for a specific Model with MODEL=MyModel
	rake slices:merb_auth_password_slice:spec:view            # Run all view specs, run specs for a specific controller (and view) with CONTROLLER=...
	rake slices:merb_auth_password_slice:stubs                # Copy stub files to host application
</code></pre>

We want to use it, so we run:

<pre><code>
	$ rake slices:merb_auth_password_slice:install
</code></pre>

Since we want to manipulate the the view, we need to freeze them with:

<pre><code>
	$ rake slices:merb_auth_password_slice:freeze:views
</code></pre>

h4. Add models

Next we create the cook, our user model

<pre><code>
	$ merb-gen model --testing-framework rspec --orm datamapper cook
</code></pre>

and the recipe resource

<pre><code>
	$ merb-gen resource --testing-framework rspec --orm datamapper recipe
</code></pre>

Now we need to add the necessary properties and associations to the cook (user) model

<pre><code>
	require 'merb_auth-more/mixins/salted_user'
	
	class Cook

	  include DataMapper::Resource
	  include Authentication::Mixins::SaltedUser

	  # Attributes
	  property :id,               Serial
	  property :login,            String
	  property :email,            String
	  property :identity_url,     String
	  property :created_at,       DateTime
	  property :updated_at,       DateTime

	  # Associations
	  has n, :recipes

	  # Validations
	  validates_present   :login, :email
	  validates_is_unique :login, :email
	  validates_format    :email, :as => :email_address

	end
</code></pre>

Mixing in the <code>Authentication::Mixins::SaltedUser</code> module does a couple of things:

* It adds two properties:
** <code>crypted_password</code> (String)
** <code>salt</code> (String)
* The new <code>password</code> property also gets two validations, if we require a password:
** validation of the presence
** validation of confirmation
* It add the following class methods:
** <code>encrypt</code>, which takes a password and salt, concatenates them with some delimiters, and encrypt the resulting string using SHA1.
** <code>authenticate</code>, which takes the login and password authenticates the user. It returns the user model if authenticated, otherwise <code>nil</code>.
* It add the following instance methods:
** <code>authenticated?</code>, which allows system to check if user is authenticated by encrypting the passed in password and comparing it to stored, crypted password.
** <code>encrypt</code>, which encrypts the password by calling the <code>encrypt</code> class method with the passed in password and the salt for that specific user (instance).
** <code>encrypt_password</code>, which calculates the salt if it is a new user and then encrypts the password for that specific user (instance).
** <code>password_required?</code>, which is used in validations.

As usual, we're more then welcome to override the methods if we desire.

And finally the recipe model

<pre><code>
	class Recipe

	  include DataMapper::Resource

	  # Attributes
	  property :id,           Integer, :serial => true
	  property :title,        String,  :nullable => false
	  property :instructions, Text,    :lazy => [:show]
	  property :created_at,   DateTime
	  property :updated_at,   DateTime

	  # Associations
	  belongs_to :cook

	  # Validations

	end
</code></pre>

Now that we have our models defined, we can run our migrations

<pre><code>
	$ rake dm:db:automigrate
</code></pre>

Next we need to hook up our recipe resource in the router:

<pre><code>
	Merb::Router.prepare do
	  # RESTful routes
	  resources :recipes
		
		...
	end</code></pre>

At this point we can fire up merb

<pre><code>
	$ merb
	 ~ Loaded DEVELOPMENT Environment...
	 ~ loading gem 'dm-timestamps' ...
	 ~ loading gem 'dm-types' ...
	 ~ loading gem 'dm-serializer' ...
	...
</code></pre>

and hit the "recipe list":http://localhost:4000/recipes.

Next we modify the views to display the info we have and allow us to enter our recipes. 
To save a bit, I'll skip listing it. Refer to source code for details.


h4. Configure login & logout

Now that we can enter, view and edit out recipes, we want to protect them.

To do that we need to do a couple of things.

First, lets hook up the merb_auth routes

<pre><code>
	Merb::Router.prepare do
	  # Authentication routes
	  match("/login", :method => :get).to(:controller => "exceptions", :action => "unauthenticated")
	  slice(:MerbAuthPasswordSlice, :path_prefix => nil, :name_prefix => nil, :default_routes => false) do
	    match("/openid").to(:controller => "sessions", :action => "update").name(:openid)
	  end
	
		...
	
	  match('/').to(:controller => 'recipes', :action =>'index')
	end
</code></pre>

and add before filter to the recipes controller:

<pre><code>
	class Recipes < Application

	  before :ensure_authenticated
	
		...
	end
</code></pre>

Then add a lib folder and add the @merb_auth_setup.rb@ file:

<pre><code>
	class Authentication

	  def self.user_class
	    Cook
	  end

	  def store_user(cook)
	    return nil unless cook
	    cook.id
	  end

	  def fetch_user(session_info)
	    Cook.get(session_info)
	  end

	end # Authentication
</code></pre>

Note that we tell MerbAuth here that our @user_class@ is @Cook@ and not the default @User@.


For it to be available, we need to adjust the Merb path in the @config/init.rb@ file:

<pre><code>
	# add 'lib' folder to path 
	Merb.push_path(:lib, File.join(File.dirname(__FILE__), "..", "lib"))
</code></pre>

As a quick and dirty test, we can create a new user via the interactive Merb shell:

<pre><code>
	$ merb -i
	 ~ Loaded DEVELOPMENT Environment...
	 ~ loading gem 'dm-timestamps' ...
	...
	 ~ Activating slice 'MerbAuthPasswordSlice' ...
	>> joe = Cook.new(:login => 'joe', :email => 'joe@example.com', :password => 'secret', :password_confirmation => 'secret')
	=> #<Cook id=nil login="joe" email="joe@example.com" crypted_password=nil salt=nil identity_url=nil created_at=nil updated_at=nil>
	>> joe.save
	 ~ SELECT `id` FROM `cooks` WHERE (`login` = 'joe') ORDER BY `id` LIMIT 1
	 ~ SELECT `id` FROM `cooks` WHERE (`email` = 'joe@example.com') ORDER BY `id` LIMIT 1
	 ~ INSERT INTO `cooks` (`crypted_password`, `created_at`, `salt`, `updated_at`, `login`, `email`) VALUES ('65c790d0621cbc7e894320cb37622f64e621f9f0', '2008-10-02 21:06:04', '67f6635aac3645850ad5073de467a7baaab177d3', '2008-10-02 21:06:04', 'joe', 'joe@example.com')
	=> true
</code></pre>

If we now quit the interactive Merb shell and start the Merb server, pointing the browser to "http://localhost:4000/recipes":http://localhost:4000/recipes should bring up the login screen. 
Entering the just created login and password will then forward us to the recipes listing.

Note: I added a link in the header to logout from the application.


h4. Protect Recipes

Right now we allow any recipe to be viewed as long as the the user can login. 
Ideally we want to protect out secret potato soup recipe from other cooks in the system.
To do that we need to modify the recipe controller. 
But first, let us add another cook to the system via the command line

<pre><code>
	$ merb -i
	 ~ Loaded DEVELOPMENT Environment...
	 ~ loading gem 'dm-timestamps' ...
	...
	 ~ Activating slice 'MerbAuthPasswordSlice' ...
	>> bill = Cook.new(:login => 'bill', :email => 'bill@example.com', :password => 'secret', :password_confirmation => 'secret')
	=> #<Cook id=nil login="bill" email="bill@example.com" crypted_password=nil salt=nil identity_url=nil created_at=nil updated_at=nil>
	>> bill.save
	 ~ SELECT `id` FROM `cooks` WHERE (`login` = 'bill') ORDER BY `id` LIMIT 1
	 ~ SELECT `id` FROM `cooks` WHERE (`email` = 'bill@example.com') ORDER BY `id` LIMIT 1
	 ~ INSERT INTO `cooks` (`crypted_password`, `created_at`, `salt`, `updated_at`, `login`, `email`) VALUES ('e88d65490e8c3deb83845f0c49f3333f955f3fed', '2008-10-02 21:50:18', '6a2984f72020c4c6e5cd5c19a3e6760b07fe832f', '2008-10-02 21:50:18', 'bill', 'bill@example.com')
	=> true
</code></pre>

Now lets create some recipes:

<pre><code>
	$ merb -i
	 ~ Loaded DEVELOPMENT Environment...
	 ~ loading gem 'dm-timestamps' ...
	...
	 ~ Activating slice 'MerbAuthPasswordSlice' ...
	>> joe = Cook.first(:login => "joe")
	 ~ SELECT `id`, `login`, `email`, `crypted_password`, `salt`, `identity_url`, `created_at`, `updated_at` FROM `cooks` WHERE (`login` = 'joe') ORDER BY `id` LIMIT 1
	=> #<Cook id=1 login="joe" email="joe@example.com" crypted_password="401518266932b42163c333c973070687b731eeb4" salt="c470ddbaff0032ac297baf842463fbd7f54649f1" identity_url=nil created_at=#<DateTime: 212089759657/86400,-1/6,2299161> updated_at=#<DateTime: 212089759657/86400,-1/6,2299161>>
	>> joe.recipes.build(:title => "Potato Soup", :instructions => "Add the diced potatoes to chicken broth. Cover, and simmer for 25 minutes.").save
	 ~ SELECT `id`, `title`, `created_at`, `updated_at`, `cook_id` FROM `recipes` WHERE (`cook_id` IN (1)) ORDER BY `id`
	 ~ INSERT INTO `recipes` (`instructions`, `created_at`, `cook_id`, `title`, `updated_at`) VALUES ('Add the diced potatoes to chicken broth. Cover, and simmer for 25 minutes.', '2008-10-02 22:08:30', 1, 'Potato Soup', '2008-10-02 22:08:30')
	=> true
	>> bill = Cook.first(:login => "bill")
	 ~ SELECT `id`, `login`, `email`, `crypted_password`, `salt`, `identity_url`, `created_at`, `updated_at` FROM `cooks` WHERE (`login` = 'bill') ORDER BY `id` LIMIT 1
	=> #<Cook id=2 login="bill" email="bill@example.com" crypted_password="7143d5223fb0f71a46291bff7d4958c0ca8c7674" salt="e1455120494795a08a5214066d1da252112f2bda" identity_url=nil created_at=#<DateTime: 21208975967/8640,-1/6,2299161> updated_at=#<DateTime: 21208975967/8640,-1/6,2299161>>
	>> bill.recipes.build(:title => "Ham N Cheese Sandwich", :instructions => "Put two slices of American cheese and on slice of ham on two slices of bread.").save
	 ~ SELECT `id`, `title`, `created_at`, `updated_at`, `cook_id` FROM `recipes` WHERE (`cook_id` IN (2)) ORDER BY `id`
	 ~ INSERT INTO `recipes` (`instructions`, `created_at`, `cook_id`, `title`, `updated_at`) VALUES ('Put two slices of American cheese and on slice of ham on two slices of bread.', '2008-10-02 22:08:51', 2, 'Ham N Cheese Sandwich', '2008-10-02 22:08:51')
	=> true
</code></pre>

Starting and logging into the application as either joe or bill shows both recipes.

First we change the <code>index</code> action in the recipes controller to only list recipes that belong to the cook/user in the session:

<pre><code>
	class Recipes < Application

	  # provides :xml, :yaml, :js

	  before :ensure_authenticated

		def index
		  @recipes = session.user.recipes
		  display @recipes
		end
		...
	end
</code></pre>

But this still provides access to another cooks recipe if I enter the URL directly, e.g. for "http://localhost:4000/recipes/2":http://localhost:4000/recipes/2 .
To avoid that simply modify the <code>show</code> action:

<pre><code>
	class Recipes < Application
		...
		def show
		  @recipe = session.user.recipes.get(params[:id])
		  raise NotFound unless @recipe
		  display @recipe
		end
		...
	end
</code></pre>

We need to adjust the <code>edit</code>, <code>update</code>, and <code>destroy</code> actions in a similar fashion.

That leaves the <code>new</code> and <code>create</code> actions. 
For the <code>new</code> action we simply add the user from the session:

<pre><code>
	class Recipes < Application
		...
		def new
		  only_provides :html
		  @recipe = Recipe.new
		  @recipe.cook = session.user
		  render
		end
		...
	end
</code></pre>

For the <code>create</code> action we use the <code>build</code> method on the <code>user.recipes</code> collection:

<pre><code>
	class Recipes < Application
		...
	  def create
	    @recipe = session.user.recipes.build(params[:recipe])
	    if @recipe.save
	      redirect url(:recipe, @recipe)
	    else
	      render :new
	    end
	  end
		...
	end
</code></pre>


h3. Unit Testing

Before we go any further, we probably should implement some unit test. Actually, we should have done it before writing any code to follow 
proper "Behavior Driven Development":http://en.wikipedia.org/wiki/Behavior_driven_development , but I guess better late then never ;).

Remember that we decided to use "RSpec":http://rspec.info/ for unit testing when we created our project. There are other good unit testing
frameworks available for Merb and it should not be to hard to convert the tests.

Ok, lets start with the models and work out way up the stack to the views.

h4. Unit Testing the Models

Since the @Recipe@ model currently does not contain any testable logic, we'll focus on the @Cook@ model.
First, lets define a helper module to make our life easier later. It contains all attributes to create a valid @Cook@ model

<pre><code>
	module CookSpecHelper
	  def cook_attributes(options = {})
	    {
	      :login => 'joe',
	      :email => 'joe@example.com',
	      :password => 'secret',
	      :password_confirmation => 'secret'
	    }.merge(options)
	  end
	end
</code></pre>

To use it, we need to include it to our first spec. At the same time, lets create a new @Cook@ object before
each (spec) example:

<pre><code>
	describe Cook do

	  include CookSpecHelper

	  before(:each) do
	    @cook = Cook.new
	  end

	end
</code></pre>

With that in hand, we turn out attention to the validations in the model:

<pre><code>
	describe Cook do
	
		...

	  it "should be invalid without a login" do
	    @cook.attributes = cook_attributes.except(:login)
	    @cook.should_not be_valid
	    @cook.errors.on(:login).should include("Login must not be blank")
	  end

	  it "should be invalid without an email" do
	    @cook.attributes = cook_attributes.except(:email)
	    @cook.should_not be_valid
	    @cook.errors.on(:email).should include("Email must not be blank")
	  end

	  it "should be valid with a full set of valid attributes" do
	    @cook.attributes = cook_attributes
	    @cook.should be_valid
	  end

	end
</code></pre>

Notice how we use our handy @cook_attributes@ method.
Time to run our newly created specs: 

<pre><code>
	$ rake spec
	(in /Users/ck/cookbook)
	...P

	Pending:
	Recipe should have specs (Not Yet Implemented)

	Finished in 0.026579 seconds

	4 examples, 0 failures, 1 pending
</code></pre>

Great all of our three cook specs passed, but we have one pending spec for the recipe as a reminder.
One more thing we probably should test is the email format validation""

<pre><code>
	describe Cook do
	
		...

		it "should be invalid without a proper email" do
		  [ "joe", "joe@", "joe example", "@example", "joe@example com" ].each do |email|
		    @cook.attributes = cook_attributes(:email => email)
		    @cook.should_not be_valid
		    @cook.errors.on(:email).should include("Email has an invalid format")
		  end
		end

	end
</code></pre>

and re-run the specs.

<pre><code>
	$ rake spec
	(in /Users/ck/cookbook)
	....P

	Pending:
	Recipe should have specs (Not Yet Implemented)

	Finished in 0.036376 seconds

	5 examples, 0 failures, 1 pending
</code></pre>

h2. Appendix

h3. Running Specs

There are multiple ways to run the specs for a Merb project. I will outline a couple of them and the order I use that I found useful. 
Pick the ones you like and make sure they fit nicely in your workflow, otherwise you will abandon tests and that is dangerous!

h4. TextMate

If you are TextMate use, you can install the RSpec Bundle (see "here":http://github.com/dchelimsky/rspec-tmbundle/wikis for instructions)
and use it to run a single example, all examples, or all examples in the folder.

One way to integrate it into your coding workflow is to

# Write the individual example.
# Run the individual example: Position cursor in example and press CMD-SHIFT-R.
# If the individual example passed, run all examples in the file: Position cursor in file and press CMD-R.
# Run all specs: Select 'spec' folder in folder drawer and press CMD-OPT-R.
# Rinse and repeat.
